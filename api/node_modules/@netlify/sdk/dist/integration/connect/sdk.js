import { writeFile } from "fs/promises";
import path from "path";
import zodLib from "zod";
import { register } from "zod-metadata";
register(zodLib);
import { catchMaybePromise } from "../../utils.js";
import { ModelBuilder } from "./model/builder.js";
import { ConnectorOptionsSchema } from "./utils/options.js";
import { ModelError } from "./model/error.js";
export class NetlifyConnector {
    config;
    apiImplementations = {}; // Content Engine APIs implemented by the plugin author
    started = false; // true if the first event loop tick has occurred. Plugin APIs cannot be dynamically assigned after this as the "exports" should be static. so this value is checked before assigning plugin APIs. It must be false to assign plugin APIs.
    warmCacheKey = `netlify-connector-warm-cache`;
    ModelBuilder;
    nodesApi = {};
    definedEvents = new Map();
    onPluginInitImplementation;
    optionsSchema;
    constructor(config) {
        this.config = config;
        console.info(`[netlify-integration] Connector initialized.`);
        this.ModelBuilder = new ModelBuilder({
            nodesApi: this.nodesApi,
        });
        this.wrapEngineApi(`onPluginInit`)((helpers, pluginOptions) => {
            if (this.optionsSchema) {
                try {
                    const packageName = helpers.store.getState()?.program?.sitePackageJson?.name ||
                        `unknown`;
                    this.optionsSchema.validate(pluginOptions, packageName);
                }
                catch (e) {
                    if (e instanceof ModelError) {
                        console.error(e.message);
                    }
                    else {
                        console.error(e);
                    }
                    process.exit(1);
                }
            }
            if (this.onPluginInitImplementation) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore no callback needed
                return this.onPluginInitImplementation(helpers, pluginOptions);
            }
        });
        this.wrapEngineApi("sourceNodes")(async ({ actions, cache }) => {
            const { enableStatefulSourceNodes } = actions;
            if (typeof enableStatefulSourceNodes !== `function`) {
                // all versions of content-engine have this API.
                // not all versions of Gatsby do. Since connectors built with this API can theoretically be run by Gatsby as well, and old versions of Gatsby, we need to throw here if the API is not available.
                throw new Error(`Your version of Gatsby is too old to support this plugin. You need gatsby@>=5.9.0 or any version of content-engine.`);
            }
            const createAllNodes = this.definedEvents.get(`createAllNodes`);
            if (!createAllNodes) {
                throw new Error(`No connector.createAllNodes(implementation) was defined. This API is required for all connectors.`);
            }
            const updateNodes = this.definedEvents.get(`updateNodes`);
            // updateNodes may be set to false, so need to check undefined
            if (typeof updateNodes === `undefined`) {
                throw new Error(`No updateNodes implementation was defined. All connectors should support incremental data fetching. If yours cannot, you can set this API to "false" so that maintainers see immediately that your plugin does no caching. ie:

connector.event('createAllNodes', () => {})
connector.event('updateNodes', false)
`);
            }
            if (updateNodes !== false) {
                // disables node garbage collection. Plugins must explicitly delete nodes themselves when they support incremental data updates.
                enableStatefulSourceNodes();
            }
            const isWarmCache = await cache.get(this.warmCacheKey);
            if (!isWarmCache) {
                await createAllNodes();
                await cache.set(this.warmCacheKey, true);
            }
            else {
                return (updateNodes || createAllNodes)();
            }
        });
        setImmediate(() => {
            // plugins may only add APIs on the first event loop tick.
            // exported APIs are static and cannot be dynamically assigned.
            this.started = true;
            if (!this.apiImplementations.createSchemaCustomization) {
                throw new Error(`No model definition for this plugin was defined via connector.model(). This API is required for all connectors.`);
            }
            if (!this.definedEvents.has(`createAllNodes`)) {
                throw new Error(`No connector.event('createAllNodes', implementation) was defined. This API is required for all connectors.`);
            }
            if (!this.definedEvents.has(`updateNodes`)) {
                throw new Error(`No connector.event('updateNodes', implementation) was defined. This API is required for all connectors.
If your connector does not support incremental data updates, please set this API to "false" so that maintainers see immediately that your plugin does no data caching.
For ex: connector.event('createAllNodes', false)`);
            }
        });
    }
    // optional Connector apis:
    onCreateNode = this.wrapEngineApi("onCreateNode");
    onPluginInit = (onInit) => {
        this.checkHasStarted(`onPluginInit`);
        this.onPluginInitImplementation = onInit;
    };
    /**
     * Defines the user configuration options for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#defineoptions
     */
    defineOptions = (definer) => {
        this.checkHasStarted(`defineOptions`);
        if (!definer || typeof definer !== `function`) {
            throw new Error(`The first argument in connector.defineOptions() must be a function that returns a zod object.`);
        }
        this.optionsSchema = new ConnectorOptionsSchema(definer);
    };
    getOptionsSchema() {
        // fallback to blank schema if no options were defined. there are default built in options that all connectors need, so if none are defined we need to make this empty one.
        this.optionsSchema ||= new ConnectorOptionsSchema(({ zod }) => zod.object({}));
        return this.optionsSchema.buildSchema();
    }
    pluginOptionsSchema = () => {
        throw new Error(`pluginOptionsSchema is deprecated. Use zod via defineOptions instead.`);
    };
    // required Connector apis:
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler) {
        this.wrapEngineApi(`createSchemaCustomization`)(async (schemaCustomizationApi, configurationOptions) => {
            const typePrefix = configurationOptions?.typePrefix ||
                this.config.typePrefix;
            const { sdl: SDL } = await this.ModelBuilder.build({
                modeler,
                typePrefix,
                cache: schemaCustomizationApi.cache,
                configurationOptions,
            });
            schemaCustomizationApi.actions.createTypes(SDL);
            if (process.env.NODE_ENV === `development` ||
                process.env.NODE_ENV === `test`) {
                await writeFile(path.join(process.cwd(), `dev-model.gql`), `# this file is automatically generated. Its only purpose is for debugging and understanding how your model definitions translate to GraphQL\n\n` +
                    SDL);
            }
        });
    }
    /**
     * Defines a data event. Supported events are `createAllNodes` and `updateNodes`.
     * @link https://sdk.netlify.com/connectors/connector-apis/#createallnodes
     */
    event(name, implementation) {
        if (this.definedEvents.has(name)) {
            throw new Error(`connector.event('${name}', implementation) was already defined. You may only define each event once.`);
        }
        this.definedEvents.set(name, () => {
            const models = this.ModelBuilder.modelDataAPIs;
            const cache = this.nodesApi.cache;
            const pluginOptions = this.nodesApi.pluginOptions;
            if (!models || !cache || !pluginOptions) {
                throw new Error(`Cannot invoke events before models have been defined.`);
            }
            if (name === `updateNodes` && implementation === false) {
                const createAllNodes = this.definedEvents.get(`createAllNodes`);
                if (!createAllNodes) {
                    throw new Error(`Cannot set updateNodes to false if createAllNodes is not defined.`);
                }
                return createAllNodes();
            }
            if (implementation === false) {
                throw new Error(`Cannot set ${name} to false.`);
            }
            return implementation({
                models,
                cache,
            }, pluginOptions);
        });
    }
    checkHasStarted(apiName) {
        if (this.started) {
            throw new Error(`Cannot call ${apiName} after the first event loop tick.\n\nPlease call connector().${apiName}() synchronously in your plugin's main module. Plugin implementations cannot be dynamically assigned.`);
        }
    }
    wrapEngineApi(apiName) {
        return (pluginApiImplementation) => {
            this.checkHasStarted(apiName);
            if (this.apiImplementations[apiName]) {
                const apiNameMap = {
                    createSchemaCustomization: `model`,
                };
                const userApiName = apiNameMap[apiName] || apiName;
                throw new Error(`Connector API ${userApiName} was defined multiple times. You may only
define each API once.`);
            }
            this.apiImplementations[apiName] = ((arg1, arg2) => {
                try {
                    // this is hacky. basically just making the public API work for now.
                    if (apiName === `sourceNodes`) {
                        this.nodesApi.createNode = arg1.actions.createNode;
                        this.nodesApi.deleteNode = arg1.actions.deleteNode;
                        this.nodesApi.createNodeId = arg1.createNodeId;
                        this.nodesApi.cache = arg1.cache;
                        this.nodesApi.pluginOptions = arg2;
                    }
                    const cleanup = () => {
                        this.nodesApi.createNode = undefined;
                        this.nodesApi.deleteNode = undefined;
                        this.nodesApi.createNodeId = undefined;
                        this.nodesApi.cache = undefined;
                        this.nodesApi.pluginOptions = undefined;
                    };
                    let modifiedArg1 = arg1;
                    if (apiName === `sourceNodes`) {
                        modifiedArg1 = {
                            ...arg1,
                            models: this.ModelBuilder.models,
                        };
                    }
                    return catchMaybePromise(
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore types are wrong, third arg is not required and not needed
                    pluginApiImplementation(modifiedArg1, arg2), (error) => {
                        if (error instanceof ModelError) {
                            console.error(error.message);
                        }
                        else {
                            console.error(error);
                        }
                        process.exit(1);
                    }, () => {
                        cleanup();
                    });
                }
                catch (e) {
                    if (e instanceof ModelError) {
                        console.error(e.message);
                    }
                    else if (e instanceof Error) {
                        console.error(e.stack);
                    }
                    else {
                        console.error(e);
                    }
                    process.exit(1);
                }
            });
        };
    }
}
