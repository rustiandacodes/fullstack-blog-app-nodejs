import { ModelDefinition, builtInTypes, mappedBuiltinTypes, } from "./definition.js";
export class ModelBuilder {
    models = new Map();
    modelDataAPIs = {};
    complete = false;
    sdl = ``;
    typePrefix = ``;
    nodesApi;
    seenTypePaths = new Map();
    constructor({ nodesApi }) {
        this.nodesApi = nodesApi;
    }
    get pluginAPI() {
        return {
            define: {
                /**
                 * Defines a node model. Nodes are database records that can be queried by their ID. Defining a type allows you to create and update nodes of that type during the createAllNodes and updateNodes data events.
                 */
                nodeModel: ({ name, fields, cacheFieldName }) => new ModelDefinition({
                    name,
                    fields,
                    kind: `Node`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                    cacheFieldName,
                }),
                /**
                 * Defines an object type. Object types are used to define fields on node models.
                 */
                object: ({ name, fields }) => new ModelDefinition({
                    name,
                    fields,
                    kind: `Object`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                }),
                /**
                 * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
                 */
                union: ({ name, types }) => new ModelDefinition({
                    name,
                    types,
                    kind: `Union`,
                    ModelBuilder: this,
                    nodesApi: this.nodesApi,
                }),
            },
        };
    }
    async build({ modeler, typePrefix, cache, configurationOptions, }) {
        this.reset();
        this.typePrefix = typePrefix;
        try {
            await modeler({
                define: this.pluginAPI.define,
                cache,
            }, configurationOptions);
        }
        catch (e) {
            console.warn(`Encountered errors while running the connector.model() API:`);
            console.error(e);
            process.exit(1);
        }
        this.validateModelHarmony();
        this.complete = true;
        this.finalizeModels();
        return {
            sdl: this.sdl,
        };
    }
    // called by the ModelDefinition constructor for all new models that are created while modelDefiner is running in this.build()
    addModel(model) {
        const typeName = model.getTypeName();
        const existingDefinition = this.models.get(typeName);
        if (existingDefinition) {
            throw new Error(`Model with name "${typeName}" was defined more than once. Model names must be unique. The first definition was:\n\n${existingDefinition.toSDL()}`);
        }
        this.setSeenTypePaths(model);
        this.models.set(typeName, model);
        if (model.isNodeType) {
            this.modelDataAPIs[typeName] = model.dataAPI;
        }
        return this;
    }
    reset() {
        this.models = new Map();
        this.seenTypePaths = new Map();
        this.modelDataAPIs = {};
        this.complete = false;
        this.sdl = ``;
    }
    finalizeModels() {
        this.sdl = ``;
        this.models.forEach((model) => {
            model.buildWalker();
            this.sdl += `${model.toSDL()}\n\n`;
        });
        this.sdl = this.sdl.trim();
    }
    // used to track which types have been referenced by other types so we can throw errors (with helpful paths) for undefined types after building models
    setSeenTypePaths(model) {
        const modelTypeName = model.getTypeName();
        if (!this.seenTypePaths.has(modelTypeName)) {
            this.seenTypePaths.set(modelTypeName, [modelTypeName]);
        }
        for (const [fieldName, fieldDefinition] of Object.entries(model.getFields())) {
            const typeName = model.getDefinedTypeName(fieldDefinition.type, fieldName);
            if (!this.seenTypePaths.has(typeName)) {
                this.seenTypePaths.set(typeName, []);
            }
            this.seenTypePaths.get(typeName).push(`${model.getTypeName()}.${fieldName}`);
        }
    }
    validateModelHarmony() {
        this.panicOnUndefinedModels();
        this.panicOnMixedUnionTypes();
    }
    panicOnMixedUnionTypes() {
        for (const model of this.models.values()) {
            if (model.isUnionType) {
                const someNodeTypes = model.compositeTypes?.some((type) => {
                    const typeName = model.getDefinedTypeName(type, model.getTypeName());
                    return this.models.get(typeName)?.isNodeType;
                });
                const someNonNodeTypes = model.compositeTypes?.some((type) => {
                    const typeName = model.getDefinedTypeName(type, model.getTypeName());
                    return !this.models.get(typeName)?.isNodeType;
                });
                if (someNodeTypes && someNonNodeTypes) {
                    throw new Error(`You cannot mix node types and non-node types in a union. You've mixed both in "${model.getTypeName()}". If you'd like to mix both, you can define a connection field on an object type in your union.`);
                }
            }
        }
    }
    panicOnUndefinedModels() {
        const undefinedModelErrors = new Map();
        for (const [seenTypeName, sdlPaths] of this.seenTypePaths.entries()) {
            if (!this.models.has(seenTypeName) &&
                !builtInTypes.has(seenTypeName) &&
                !mappedBuiltinTypes.has(seenTypeName)) {
                if (!undefinedModelErrors.has(seenTypeName)) {
                    undefinedModelErrors.set(seenTypeName, new Set());
                }
                for (const sdlPath of sdlPaths) {
                    undefinedModelErrors.get(seenTypeName).add(sdlPath);
                }
            }
        }
        if (undefinedModelErrors.size > 0) {
            const errorMessages = Array.from(undefinedModelErrors.entries()).map(([typeName, sdlPaths]) => {
                return `Undefined type "${typeName}", referenced on type fields:\n\n${Array.from(sdlPaths.keys())
                    .map((sdlPath) => {
                    return ` - ${sdlPath}`;
                })
                    .join(`\n`)}\n`;
            });
            errorMessages.forEach((message) => {
                console.error(message);
            });
            if (undefinedModelErrors.size > 1) {
                console.error(`There were ${undefinedModelErrors.size} referenced type names which haven't been defined. Either your plugin has a typo or there are types which haven't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            else {
                console.error(`There was 1 referenced type name which hasn't been defined. Either your plugin has a typo or there is a type which hasn't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            process.exit(1);
        }
    }
}
