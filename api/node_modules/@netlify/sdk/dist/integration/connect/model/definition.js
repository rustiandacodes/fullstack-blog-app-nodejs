import camelcase from "camelcase";
// We need this one as it's the one that is used in the content-engine
import _ from "lodash";
import { ModelWalker } from "./walker.js";
import { ModelError } from "./error.js";
// todo - this should be imported from content-engine
export const builtInTypes = new Set([
    `ID`,
    `String`,
    `Int`,
    `Float`,
    `Boolean`,
    `JSON`,
    `Date`,
]);
export const mappedBuiltinTypes = new Map([
    ...Array.from(builtInTypes).map((type) => {
        return [type.toLowerCase(), type];
    }),
    // additional mappings
    [`integer`, `Int`], [`number`, `Float`]
]);
export class ModelDefinition {
    compositeTypes = [];
    compositeTypesSet = new Set();
    description;
    cacheFieldName;
    ModelWalker;
    definedKind;
    typeName;
    fields = {};
    ModelBuilder;
    nodesApi;
    constructor(input) {
        this.typeName = input.name;
        this.definedKind = input.kind;
        this.description = input.description;
        this.fields = input.fields || {};
        this.compositeTypes = input.types;
        this.nodesApi = input.nodesApi;
        this.validateDefinition(input);
        this.compositeTypes?.forEach((type) => {
            this.compositeTypesSet.add(this.getDefinedTypeName(type));
        });
        this.cacheFieldName = input.cacheFieldName;
        this.ModelWalker = new ModelWalker({
            model: this,
            getModelByName: this.getModelByName,
        });
        this.ModelBuilder = input.ModelBuilder.addModel(this);
        return this;
    }
    getFields() {
        return this.fields;
    }
    getTypeName() {
        return this.typeName;
    }
    get isNodeType() {
        return this.definedKind === `Node`;
    }
    get isObjectType() {
        return this.definedKind === `Object`;
    }
    get isUnionType() {
        return this.definedKind === `Union`;
    }
    getDefinedTypeName(type, fieldName) {
        const isDefineInstance = type instanceof ModelDefinition;
        const typeName = isDefineInstance ? type.typeName : type;
        if (typeof typeName === `undefined`) {
            throw new ModelError(`The type of field "${fieldName}" is undefined. Please define the type of this field.`);
        }
        return typeName;
    }
    prefixedTypeName(typeName = this.typeName) {
        if (builtInTypes.has(typeName)) {
            return typeName;
        }
        return `${this.ModelBuilder.typePrefix}${typeName}`;
    }
    get dataAPI() {
        return {
            create: this.create,
            delete: this.delete,
        };
    }
    buildWalker() {
        return this.ModelWalker.build();
    }
    getModelByName(typeName) {
        return this.ModelBuilder.models.get(typeName);
    }
    hasField(fieldName) {
        return !!this.fields[fieldName];
    }
    get delete() {
        return (nodes) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call delete() on a non-node type. You can only delete nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const deleteNode = this.nodesApi?.deleteNode;
            if (!deleteNode) {
                throw new ModelError(`models.${this.typeName}.delete() can only be called inside createAllNodes or updateNodes Connector events.`);
            }
            if (Array.isArray(nodes)) {
                return nodes.map((id) => {
                    return deleteNode({
                        id: this.createNodeId(id),
                        internal: {
                            type: this.prefixedTypeName(),
                            contentDigest: `0`,
                        },
                    });
                });
            }
            return deleteNode({
                id: this.createNodeId(nodes),
                internal: {
                    type: this.prefixedTypeName(),
                    contentDigest: `0`,
                },
            });
        };
    }
    get create() {
        return (nodes) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call create() on a non-node type. You can only create nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const createNode = this.nodesApi?.createNode;
            if (!createNode) {
                throw new ModelError(`models.${this.typeName}.create() can only be called inside createAllNodes or updateNodes Connector events.`);
            }
            if (!nodes || (Array.isArray(nodes) && !nodes.length)) {
                throw new ModelError(`models.${this.typeName}.create() must be called with a node or array of nodes.\n\nProvided value:\n${JSON.stringify(nodes, null, 2)}`);
            }
            if (Array.isArray(nodes)) {
                return nodes.map((node) => createNode(this.prepareNode(node)));
            }
            return createNode(this.prepareNode(nodes));
        };
    }
    createNodeId(rawId) {
        const createNodeId = this.nodesApi?.createNodeId;
        if (!createNodeId) {
            throw new ModelError(`models.${this.typeName}.createNodeId() can only be called inside createAllNodes or updateNodes Connector events.`);
        }
        return createNodeId(`${this.prefixedTypeName()}${rawId}`);
    }
    prepareNode(node) {
        return this.ModelWalker.coerceModelValue(node);
    }
    toSDL() {
        if (this.isUnionType && this.compositeTypes) {
            return `union ${this.prefixedTypeName()} = ${this.compositeTypes
                .map((type) => this.prefixedTypeName(this.getDefinedTypeName(type, this.getTypeName())))
                .join(` | `)}`;
        }
        else if (this.isUnionType) {
            throw new ModelError(`You've defined a union type ("${this.getTypeName()}") but haven't provided any composite types.`);
        }
        // building up SDL strings instead of using type builders in case we want to remove graphql-compose later. definitions are intentionally simple, so model shouldn't be an issue.
        let sdl = ``;
        if (this.description) {
            sdl += `"""${this.description}"""\n`;
        }
        sdl += `type ${this.prefixedTypeName()} `;
        if (this.isNodeType) {
            sdl += `implements Node @dontInfer `;
        }
        sdl += `{\n`;
        Object.entries(this.getFields()).forEach(([fieldName, fieldType]) => {
            if (fieldType?.description) {
                sdl += `  """${fieldType.description}"""\n`;
            }
            sdl += `  ${fieldName}: `;
            const { type, required, list } = fieldType;
            const fieldTypeName = this.getDefinedTypeName(type, fieldName);
            let fieldSdl = ``;
            if (list) {
                fieldSdl += `[`;
            }
            fieldSdl += this.prefixedTypeName(fieldTypeName);
            if (required) {
                fieldSdl += `!`;
            }
            if (list) {
                fieldSdl += `]`;
            }
            if (list === `required`) {
                fieldSdl += `!`;
            }
            const fieldModel = this.ModelBuilder.models.get(fieldTypeName);
            let isNodeType = fieldModel?.isNodeType;
            if (fieldModel?.isUnionType) {
                isNodeType = fieldModel.compositeTypes?.some((type) => {
                    const typeName = this.getDefinedTypeName(type, this.getTypeName());
                    return this.getModelByName(typeName)?.isNodeType;
                });
            }
            if (isNodeType) {
                fieldSdl += ` @link(from: "${fieldName}.id")`;
            }
            sdl += `${fieldSdl}\n`;
        });
        sdl += `}`;
        return sdl;
    }
    containsIllegalChars(str) {
        return /[^a-zA-Z0-9]/.test(str);
    }
    validateDefinition(definition) {
        if (this.definedKind !== `Node` && definition.cacheFieldName) {
            throw new ModelError(`You cannot provide a "cacheFieldName" for a non-Node type. "cacheFieldName" is only valid when using define.nodeModel({ ... }). This setting specifies which property on nodes should be used to invalidate each cached node.`);
        }
        if (!definition.name) {
            throw new ModelError(`You must provide a name when defining a type. For example: define.methodName({ name: "MyType", ... })`);
        }
        if (this.containsIllegalChars(definition.name)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${definition.name}" is not valid.`);
        }
        if (camelcase(definition.name, {
            pascalCase: true,
        }) !== definition.name) {
            throw new Error(`Model and type names must be in PascalCase. "${definition.name}" is not a valid name.`);
        }
        if (typeof definition.name !== `string`) {
            throw new ModelError(`The name of a model must be a string. For example: define.nodeModel({ name: "MyType", ... })`);
        }
        Object.entries(this.fields).forEach(([fieldName, fieldDefinition]) => {
            this.validateFieldDefinition(fieldName, fieldDefinition);
        });
        if (this.cacheFieldName) {
            if (!this.fields[this.cacheFieldName]) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but haven't defined a field with that name.`);
            }
            if (!this.fields[this.cacheFieldName].required) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field is not defined it as required. For proper cache invalidation this field must always exist.`);
            }
        }
        if (definition.cacheFieldName &&
            !this.hasField(definition.cacheFieldName)) {
            throw new ModelError(`You've defined a cacheFieldName ("${definition.cacheFieldName}") but haven't defined a field with that name.`);
        }
        if (definition.cacheFieldName &&
            !this.fields[definition.cacheFieldName].required) {
            throw new ModelError(`You've defined a cacheFieldName ("${definition.cacheFieldName}") but that field is not defined as required. For proper cache invalidation this field must always exist and thus must be set as "required".`);
        }
        if (definition.cacheFieldName &&
            this.fields[definition.cacheFieldName].list) {
            throw new ModelError(`You've defined a cacheFieldName ("${definition.cacheFieldName}") but that field type is a list. For proper cache invalidation the cacheFieldName can only be set to a non-list field type.`);
        }
        if (definition.cacheFieldName &&
            this.fields[definition.cacheFieldName].type !== `String`) {
            throw new ModelError(`You've defined a cacheFieldName ("${definition.cacheFieldName}") For proper cache invalidation the cacheFieldName can only be set to a "String" field type. The "${definition.cacheFieldName}" field is of type "${this.getDefinedTypeName(this.fields[definition.cacheFieldName].type)}".`);
        }
    }
    validateFieldDefinition(fieldName, fieldType) {
        if (typeof fieldName !== `string`) {
            throw new ModelError(`Field names must be strings. "${JSON.stringify(fieldName, null, 2)}" is not a string`);
        }
        if (this.containsIllegalChars(fieldName)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${fieldName}" is not valid.`);
        }
        if (fieldName.match(/^\d/)) {
            throw new ModelError(`Names cannot start with a number. "${fieldName}" is not valid.`);
        }
        if (_.camelCase(fieldName) !== fieldName) {
            throw new ModelError(`Field names must be camelCased. "${fieldName}" is not a valid field name.`);
        }
        if (typeof fieldType !== `object` || Array.isArray(fieldType)) {
            throw new ModelError(`Field type definitions must be objects. "${JSON.stringify(fieldType, null, 2)}" is not an object.`);
        }
        if (typeof fieldType.type === `string`) {
            const lowercasedBuiltIn = mappedBuiltinTypes.get(fieldType.type);
            if (lowercasedBuiltIn) {
                fieldType.type = lowercasedBuiltIn;
            }
        }
        const fieldTypeName = this.getDefinedTypeName(fieldType.type, fieldName);
        if (typeof fieldTypeName !== `string`) {
            throw new ModelError(`Field definition "${fieldName}.type" must be defined as a string. For ex -> ${fieldName}: { type: "Boolean" }
Instead you have defined it as "${JSON.stringify(fieldTypeName, null, 2)}"`);
        }
        if ([`[`, `]`, `!`].some((char) => fieldTypeName.includes(char))) {
            throw new ModelError(`The type of field "${fieldName}" must not be an SDL string.
For example this is not allowed
  ${fieldName}: { type: "${fieldTypeName}" }
use something like the following instead
  ${fieldName}: { type: "${fieldTypeName
                .replaceAll(`[`, ``)
                .replaceAll(`]`, ``)
                .replaceAll(`!`, ``)}", required: ${fieldTypeName.includes(`!`)}${fieldTypeName.includes(`[`)
                ? `, list: ${fieldTypeName.includes(`]!`) ? `"required"` : `true`}`
                : ``} }`);
        }
        if (fieldName.toLowerCase() === `id` ||
            fieldName === `internal` ||
            fieldName === `fields`) {
            throw new ModelError(`"${fieldName}" is a reserved field name, please choose a different field name.`);
        }
        if (this.isUnionType && !this.compositeTypes?.length) {
            throw new ModelError(`You must provide at least one type when defining a union. For example: define.union({ name: "MyUnion", types: ["MyType"] })`);
        }
    }
}
