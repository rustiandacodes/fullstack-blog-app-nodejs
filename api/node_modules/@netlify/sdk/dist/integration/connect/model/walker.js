import { builtInTypes } from "./definition.js";
import { ModelError } from "./error.js";
export class ModelWalker {
    model;
    getModelByName;
    coersionFields = [];
    allowedFieldNames = new Set();
    constructor({ model, getModelByName, }) {
        this.model = model;
        this.getModelByName = getModelByName.bind(this.model);
    }
    build() {
        if (this.model.isNodeType) {
            this.allowedFieldNames.add(`id`);
            this.coersionFields.push({
                fieldName: `id`,
                fieldTypeName: `ID`,
                required: true,
                list: false,
            });
        }
        if (this.model.isUnionType && this.model.compositeTypes) {
            this.allowedFieldNames.add(`__typename`);
            for (const type of this.model.compositeTypes) {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                const typeModel = this.getModelByName(typeName);
                if (!typeModel) {
                    throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.model.getTypeName()}".\n\nAll union model values must have a "__typename" which identifies the correct type of the provided value. You may have a typo in your "__typename" value or you may need to define the ${typeName} model.`);
                }
                if (typeModel.isNodeType) {
                    this.allowedFieldNames.add(`id`);
                }
                for (const fieldName of Object.keys(typeModel.getFields())) {
                    this.allowedFieldNames.add(fieldName);
                }
            }
        }
        for (const [fieldName, fieldDefinition] of Object.entries(this.model.getFields())) {
            const fieldTypeName = this.model.getDefinedTypeName(fieldDefinition.type, fieldName);
            const isBuiltInType = builtInTypes.has(fieldTypeName);
            const fieldModel = this.getModelByName(fieldTypeName);
            if (!fieldModel && !isBuiltInType) {
                throw new ModelError(`Could not find model for field type "${fieldTypeName}" in model "${this.model.getTypeName()}"`);
            }
            this.allowedFieldNames.add(fieldName);
            const required = fieldDefinition.required || fieldDefinition?.list === `required`;
            if (required || !isBuiltInType) {
                this.coersionFields.push({
                    fieldName,
                    fieldTypeName,
                    model: fieldModel,
                    required: !!fieldDefinition.required,
                    list: fieldDefinition.list || false,
                });
            }
        }
    }
    coerceModelValue(modelValue, path = [], combinedType) {
        const isRoot = !path.length;
        const coercedValue = { ...modelValue };
        this.setNodeId(coercedValue, path);
        this.throwOnMissingTypename(coercedValue, path);
        if (process.env.NODE_ENV !== `production`) {
            this.throwOnIncorrectUnionTypename(coercedValue, path, combinedType);
            this.throwOnUndefinedModelFields(coercedValue, path, combinedType);
        }
        const handledUnionValue = this.handleUnionValue(coercedValue, path);
        if (handledUnionValue)
            return handledUnionValue;
        this.coerceFields(coercedValue, path);
        this.setInternalProperty(coercedValue, isRoot);
        return coercedValue;
    }
    setNodeId(coercedValue, path) {
        if (this.model.isNodeType) {
            const rawId = coercedValue.id;
            // If the node is a root node (ie no path yet), we need to add the type name to the path for error messages. ex: "MyModel.foo.bar.id"
            if (!path.length) {
                path.push(`${this.model.getTypeName()}`);
                path.push(`(rawId='${rawId}')`);
            }
            if (!rawId) {
                throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll nodes must have an "id" field which identifies the node.`);
            }
            coercedValue.id = this.model.createNodeId(rawId);
        }
    }
    handleUnionValue(coercedValue, path) {
        if (this.model.isUnionType) {
            const asType = coercedValue.__typename;
            const asModel = this.getModelByName(asType);
            if (!asModel) {
                throw new ModelError(`Could not find model for union type "${asType}" in model "${this.model.getTypeName()}" at node path "${path.join(`.`)}".\n\nAll union model values must have a "__typename" which identifies the correct type of the provided value. You may have a typo in your "__typename" value or you may need to define the ${asType} model.`);
            }
            if (asModel.isNodeType) {
                const rawId = coercedValue?.id;
                if (!rawId) {
                    throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll node type union model values must have an "id" which identifies the node connection field. The type of the model in this union is "${asModel.getTypeName()}"`);
                }
                coercedValue.id = asModel.createNodeId(rawId);
                delete coercedValue.__typename;
                coercedValue.internal ||= {};
                coercedValue.internal.type = asModel.prefixedTypeName();
                return coercedValue;
            }
            return asModel.ModelWalker.coerceModelValue(coercedValue, path, this.model);
        }
    }
    coerceFields(coercedValue, path) {
        for (const field of this.coersionFields) {
            const modelFieldValue = coercedValue[field.fieldName];
            const isList = field.list === true || field.list === `required`;
            const isRelationship = field.model?.isNodeType;
            const isRequiredList = field.list === `required`;
            const fieldMustBeNonNull = field.required || isRequiredList;
            const fieldIsNullOrUndefined = typeof modelFieldValue === `undefined` && modelFieldValue !== null;
            const isEmptyList = !!modelFieldValue && !modelFieldValue?.filter?.(Boolean)?.length;
            const shouldThrow = (fieldMustBeNonNull && fieldIsNullOrUndefined) ||
                (isRequiredList && isEmptyList);
            const modelString = `Insertion failed validation\n  -> for model "${this.model.getTypeName()}"\n  -> on`;
            const pathString = shouldThrow
                ? `  -> at input path ${path.join(`.`)}.${field.fieldName} <- this field\n  -> required field type "${field.fieldTypeName}${field.list ? `[]` : ``}"\n  -> provided field value:\n    -> ${field.fieldName} is "${JSON.stringify(modelFieldValue, null, 2)}"`.substring(0, 250) + `\n...`
                : undefined;
            if (shouldThrow && isList && isRelationship) {
                throw new ModelError(`${modelString} required list field "${field.fieldName}".\n    -> This field must be an array of strings that are node IDs ${pathString}`);
            }
            else if (shouldThrow && isList) {
                throw new ModelError(`${modelString} required list field "${field.fieldName}" ${pathString}`);
            }
            else if (shouldThrow && isRelationship) {
                throw new ModelError(`${modelString} required field "${field.fieldName}". This field value must be a node id string ${pathString}`);
            }
            else if (shouldThrow) {
                throw new ModelError(`${modelString} required field "${field.fieldName}" ${pathString}`);
            }
            else if (fieldIsNullOrUndefined) {
                continue;
            }
            if (!field.list && field.model?.isNodeType) {
                const rawId = modelFieldValue?.id || modelFieldValue;
                coercedValue[field.fieldName] = {
                    id: field.model.createNodeId(rawId),
                    internal: {
                        type: field.model.prefixedTypeName(),
                    },
                };
                continue;
            }
            else if (field.list && field.model?.isNodeType) {
                const fieldModel = field.model;
                if (!fieldModel) {
                    throw new ModelError(`Could not find model for field type: ${JSON.stringify(field, null, 2)})}`);
                }
                coercedValue[field.fieldName] = modelFieldValue.map((modelFieldValueListItem) => {
                    const rawId = modelFieldValueListItem?.id || modelFieldValueListItem;
                    if (typeof rawId !== `string` &&
                        typeof modelFieldValueListItem !== `undefined`) {
                        throw new ModelError(`Invalid "${this.model.getTypeName()}" input object: ${JSON.stringify(coercedValue, null, 4).replace(`    "${field.fieldName}": `, `--> "${field.fieldName}": `)}\n\nThe value at input path "${path.join(`.`)}.${field.fieldName}${field.list ? `[]` : ``}.id" is not a valid node id string.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
                    }
                    else if (typeof rawId !== `string`) {
                        throw new ModelError(`Invalid "${this.model.getTypeName()}" input object: ${JSON.stringify(coercedValue, null, 4).replace(`    "${field.fieldName}": `, `-->"${field.fieldName}": `)}\n\nThe value at input path "${path.join(`.`)}.${field.fieldName}" is not a valid node id string.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
                    }
                    return {
                        id: fieldModel.createNodeId(rawId),
                        internal: {
                            type: fieldModel.prefixedTypeName(),
                        },
                    };
                });
                continue;
            }
            if (field.model && !field.list) {
                coercedValue[field.fieldName] =
                    field.model.ModelWalker.coerceModelValue(modelFieldValue, [...path, field.fieldName]);
                continue;
            }
            else if (field.model && field.list) {
                coercedValue[field.fieldName] = modelFieldValue.map((node, index) => field.model.ModelWalker.coerceModelValue(node, [
                    ...path,
                    field.fieldName,
                    `[${index}]`,
                ]));
                continue;
            }
        }
    }
    setInternalProperty(coercedValue, isRoot = false) {
        if (isRoot) {
            const { cacheFieldName } = this.model;
            const cacheFieldValue = cacheFieldName
                ? coercedValue[cacheFieldName]
                : Math.random();
            if (!cacheFieldValue) {
                throw new ModelError(`A cacheFieldName ("${cacheFieldName}") is defined but the input value at ${this.model.getTypeName()}.${cacheFieldName} is falsy. This value must always be defined and truthy.`);
            }
            coercedValue.internal ||= {};
            coercedValue.internal.contentDigest = String(cacheFieldValue);
            coercedValue.internal.type = this.model.prefixedTypeName();
        }
        else if (coercedValue.__typename) {
            // connection union fields will have a __typename but no cacheFieldName. internal.type needs to be set for content engine resolvers to work
            delete coercedValue.__typename;
            coercedValue.internal ||= {};
            coercedValue.internal.type = this.model.prefixedTypeName();
        }
    }
    throwOnMissingTypename(coercedValue, path) {
        if (this.model.isUnionType && !coercedValue.__typename) {
            throw new ModelError(`Union model "${this.model.getTypeName()}" insertion failed validation for required field "__typename".\nAll union model values must have a "__typename" which identifies the type of the provided value.\nThe value at input path "${path.join(`.`)}" is missing a "__typename".`);
        }
    }
    throwOnIncorrectUnionTypename(coercedValue, path, combinedType) {
        if ((this.model.isUnionType || combinedType?.isUnionType) &&
            coercedValue.__typename) {
            const typeIsInUnion = (combinedType || this.model).compositeTypes?.some((type) => {
                const typeName = this.model.getDefinedTypeName(type, this.model.getTypeName());
                return typeName === coercedValue.__typename;
            });
            if (!typeIsInUnion) {
                throw new ModelError(`Union model "${this.model.getTypeName()}" insertion failed validation for required field "__typename".\nThe value at input path "${path.join(`.`)}" has a "__typename" of "${coercedValue.__typename}" but that type is not in the "${(combinedType || this.model).getTypeName()}" union.`);
            }
        }
    }
    throwOnUndefinedModelFields(modelValue, path, combinedType) {
        // throw for any properties that are not defined as fields on the model
        Object.keys(modelValue || {}).forEach((key) => {
            if (key === `__typename` && combinedType?.isUnionType) {
                return;
            }
            if (!this.allowedFieldNames.has(key)) {
                const modelTypeName = this.model.getTypeName();
                console.warn(`Invalid "${modelTypeName}" input object: ${JSON.stringify(modelValue, null, 4).replace(`    "${key}": `, `--> "${key}": `)}\n`);
                throw new ModelError(`Model "${modelTypeName}"\n  -> has no field named "${key}"\n  -> an invalid property with that name exists on the input object\n  -> in models.${path[0]}.create()\n  -> at input object path:\n    ${path.join(`.`)}.${key}\n\nDefine the "${key}" field on model "${modelTypeName}" or remove the field from the input object to resolve this error.`);
            }
        });
    }
}
