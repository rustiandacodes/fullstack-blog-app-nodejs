import fetch from "node-fetch";
import { ZodError } from "zod";
import { NetlifyIntegrationClient } from "../api/index.js";
import { INTEGRATION_API_URL } from "../constants/urls.js";
import { NetlifyConnector, } from "./connect/sdk.js";
import { defaultOnDisableHandler, defaultOnDisconnectHandler, defaultOnEnableHandler, } from "./api/handlers.js";
export class NetlifyIntegration {
    _buildHooks;
    _wrappers;
    _handlers;
    _netlifyConnectPlugin;
    _buildConfigurationSchema;
    _buildContextSchema;
    _siteConfigSchema;
    _teamConfigSchema;
    _slug = "";
    _buildHooksOptions;
    constructor({ buildConfigSchema, buildContextSchema, siteConfigSchema, teamConfigSchema, } = {}) {
        this._buildHooks = {
            onPreBuild: null,
            onBuild: null,
            onPostBuild: null,
            onSuccess: null,
            onError: null,
            onEnd: null,
        };
        this._buildHooksOptions = {
            onPreBuild: null,
            onBuild: null,
            onPostBuild: null,
            onSuccess: null,
            onError: null,
            onEnd: null,
        };
        this._buildConfigurationSchema = buildConfigSchema;
        this._buildContextSchema = buildContextSchema;
        this._siteConfigSchema = siteConfigSchema;
        this._teamConfigSchema = teamConfigSchema;
        this._handlers = {
            "on-enable": defaultOnEnableHandler,
            "on-disable": defaultOnDisableHandler,
            "on-disconnect": defaultOnDisconnectHandler,
        };
        this._wrappers = {};
    }
    get buildSlug() {
        return this._slug.toUpperCase().replaceAll(/[^A-Z_]/g, "_");
    }
    /**
     * Used to add a build event handlers to the integration.
     */
    addBuildEventHandler(type, func, options) {
        if (options) {
            this._buildHooksOptions[type] = options;
        }
        this._buildHooks[type] = async (context) => {
            const buildToken = process.env[`${this.buildSlug}_BUILD_TOKEN`];
            const { netlifyConfig } = context;
            const buildConfig = this.getBuildConfig({ netlifyConfig });
            if (buildToken) {
                const siteId = process.env.SITE_ID;
                const integrationResponse = await fetch(`https://api.netlifysdk.com/site/${siteId}/integrations/safe`);
                let url = `https://netlify-integration-${this._slug}.netlify.app`;
                if (integrationResponse.ok) {
                    const integrations = (await integrationResponse.json());
                    const integration = integrations.find((integration) => integration.slug === this._slug);
                    if (integration) {
                        url = integration.version;
                    }
                }
                const buildContextResponse = await fetch(`${url}/.netlify/functions/handler/build-context`, {
                    method: "POST",
                    headers: {
                        ["netlify-token"]: buildToken,
                    },
                    body: JSON.stringify({
                        site_id: process.env.SITE_ID,
                        token: buildToken,
                    }),
                });
                if (!buildContextResponse.ok) {
                    console.warn("Failed to fetch build context, skipping");
                    return;
                }
                let buildContext = undefined;
                try {
                    buildContext = (await buildContextResponse.json());
                }
                catch (e) {
                    /* empty */
                }
                return func({ ...context, buildContext, buildConfig });
            }
            return func({ ...context, buildConfig });
        };
    }
    /**
     * Used to add a build context to the integration that can be used in a build hook.
     */
    addBuildEventContext(handler) {
        this._handlers["build-context"] = async (event, { client }) => {
            if (event.httpMethod !== "POST") {
                return {
                    statusCode: 405,
                };
            }
            const body = JSON.parse(event.body || "{}");
            const { site_id } = body;
            const { team_id, token } = await client.exchangeBuildToken(site_id);
            const newClient = new NetlifyIntegrationClient(token, this._slug);
            const { config } = await newClient.getSiteIntegration(site_id);
            const buildContextContext = {
                site_id,
                site_config: config,
                client: newClient,
            };
            if (team_id) {
                const { config } = await newClient.getTeamIntegration(team_id);
                buildContextContext.team_id = team_id;
                buildContextContext.team_config = config;
            }
            const buildContext = await handler(buildContextContext);
            return {
                statusCode: 200,
                body: JSON.stringify(buildContext),
            };
        };
    }
    /**
     * Used to add an API Handler to the integration.
     */
    addApiHandler(name, handler) {
        this._handlers[name] = handler;
    }
    /**
     * Used to add a Wrapper to the integration.
     * @ignore for Typedoc
     */
    addWrapper(name, handler) {
        this._wrappers[name] = handler;
    }
    /**
     * The handler to use for the onEnable endpoint.
     */
    onEnable(handler) {
        this._handlers["on-enable"] = async (event, context) => {
            const res = await defaultOnEnableHandler(event, context);
            if (res.statusCode !== 200) {
                return res;
            }
            const { siteId, teamId } = JSON.parse(event.body ?? "{}");
            return handler(event, { ...context, siteId, teamId });
        };
    }
    /**
     * The handler to use for the onDisable endpoint.
     */
    onDisable(handler) {
        this._handlers["on-disable"] = async (event, context) => {
            const { siteId, teamId } = event.queryStringParameters || {};
            if (!siteId && !teamId) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing siteId or teamId" }),
                };
            }
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200) {
                return integrationHandlerRes;
            }
            return await defaultOnDisableHandler(event, context);
        };
    }
    /**
     * The handler to use for the onDisconnect endpoint.
     */
    onDisconnect(handler) {
        this._handlers["on-disconnect"] = async (event, context) => {
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200) {
                return integrationHandlerRes;
            }
            return {
                statusCode: 200,
                body: "Disconnected",
            };
        };
    }
    /**
     * @ignore for Typedoc
     */
    addWebhookHandler(name, handler) {
        const webhookName = name ? `webhook-${name}` : "webhook";
        this._handlers[webhookName] = handler;
    }
    get buildHooks() {
        return this._buildHooks;
    }
    get buildHooksOptions() {
        return this._buildHooksOptions;
    }
    get handlers() {
        return this._handlers;
    }
    get wrappers() {
        return this._wrappers;
    }
    get baseHandler() {
        return async (event, context) => {
            const responseHeaders = {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "*",
                "Access-Control-Allow-Methods": "*",
            };
            // Fetch the path components from /api/<name> or /.netlify/functions/<name>
            // match with regex
            const routeRegex = /^(?:\/.netlify\/functions\/handler\/|\/api\/)([^/]+)(\/.*)?$/;
            const components = event.path.match(routeRegex);
            const name = components?.[1] ?? "not-found";
            const webhookHandler = name.startsWith("webhook");
            const handler = this._handlers[name];
            if (handler) {
                // Allow CORS preflight requests where the request does not come from the same origin
                if (event.httpMethod === "OPTIONS") {
                    return {
                        statusCode: 200,
                        headers: responseHeaders,
                    };
                }
                let nfToken = event.headers["cookie"]
                    ?.split(";")
                    .find((c) => c.includes("_nf-auth"))
                    ?.split("=")[1];
                if (!nfToken) {
                    nfToken = event.headers["netlify-token"];
                }
                if (!nfToken && !webhookHandler) {
                    return {
                        statusCode: 401,
                        headers: responseHeaders,
                        body: JSON.stringify({
                            error: "Unauthorized",
                        }),
                    };
                }
                const netlifyApiUrl = process.env.NETLIFY_API_BASE_URL ?? `${INTEGRATION_API_URL}/api/v1`;
                const client = new NetlifyIntegrationClient(nfToken ?? "", this._slug, {
                    netlifyApiUrl,
                });
                const { siteId, teamId } = event.queryStringParameters ?? {};
                const { "provider-oauth-token": providerOAuthToken } = event.headers;
                event.path = `/${name}${components?.[2] ?? ""}`;
                try {
                    const response = await handler(event, {
                        ...context,
                        siteId,
                        teamId,
                        providerOAuthToken,
                        client,
                    });
                    response.headers = {
                        ...responseHeaders,
                        ...response.headers,
                    };
                    return response;
                }
                catch (e) {
                    console.error(e);
                    return {
                        statusCode: 500,
                        headers: responseHeaders,
                        body: "An unhandled error occurred",
                    };
                }
            }
            return {
                statusCode: 404,
                headers: responseHeaders,
                body: JSON.stringify({
                    error: `Handler ${name} not found`,
                }),
            };
        };
    }
    /**
     * Deprecated
     * @deprecated createConnector has been renamed to addConnector
     */
    createConnector(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _config) {
        throw new Error(`integration.createConnector() has been renamed to integration.addConnector()`);
    }
    /**
     * Used to create a Connector for the integration.
     */
    addConnector(config) {
        if (this._netlifyConnectPlugin) {
            throw new Error(`Connector plugin already exists. Only one Netlify Connect Plugin can be built per integration.`);
        }
        if (!config?.typePrefix) {
            throw new Error(`You must provide a default typePrefix when creating a connector.`);
        }
        const connector = new NetlifyConnector(config);
        this._netlifyConnectPlugin = connector;
        return connector;
    }
    get netlifyConnectPlugin() {
        return this._netlifyConnectPlugin ?? null;
    }
    getBuildConfig({ netlifyConfig }) {
        let buildConfig;
        // Attempt to find the integration-specific configuration data
        const integrations = netlifyConfig?.integrations || [];
        if (Array.isArray(integrations)) {
            const integration = integrations.find((integration) => integration.name === this._slug);
            if (integration) {
                if (this._buildConfigurationSchema && integration.config) {
                    try {
                        buildConfig = this._buildConfigurationSchema.parse(integration.config);
                    }
                    catch (e) {
                        if (e instanceof ZodError) {
                            console.error("Failed to parse build configuration:", e.message);
                        }
                        return;
                    }
                }
            }
        }
        return buildConfig;
    }
    getBuildEventHandlersToRun({ netlifyConfig, }) {
        const buildConfig = this.getBuildConfig({ netlifyConfig }) || {};
        return Object.entries(this._buildHooks || {}).reduce((acc, [key, buildEventHandler]) => {
            if (!buildEventHandler) {
                return acc;
            }
            const dynamicConditional = this.buildHooksOptions?.[key]?.if;
            if (!dynamicConditional ||
                (dynamicConditional instanceof Function &&
                    dynamicConditional(buildConfig))) {
                acc[key] = buildEventHandler;
            }
            return acc;
        }, {});
    }
}
