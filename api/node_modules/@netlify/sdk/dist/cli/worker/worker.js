import path from "path";
import { parentPort, workerData } from "worker_threads";
import fsExtra from "fs-extra";
import { zodToGraphqlSdl } from "../../integration/connect/utils/zod-to-sdl.js";
import { getConfiguration, getIntegrationModule, } from "../../cli/util.js";
const { writeFile, ensureDir } = fsExtra;
// this worker is used to load the latest version of the integration module.
// because esm doesn't allow clearing the require cache, this allows us to get the latest version of the integration module including any user code changes.
// previously we just appended a query param to the import, but that creates a memory leak where copies of the same module are loaded into memory over and over again and never garbage collected.
class IntegrationWorker {
    integrationModulePath;
    integrationDirectory;
    integration;
    config;
    constructor() {
        if (!parentPort) {
            throw new Error("No parent port. integrationWorker must be run in a worker thread.");
        }
        const { integrationPath } = workerData;
        if (!integrationPath) {
            throw new Error(`No integration path provided.`);
        }
        this.integrationModulePath = integrationPath;
        this.integrationDirectory = path.dirname(integrationPath);
        parentPort.on(`message`, async (message) => {
            const { type, id, payload } = message;
            if (!type) {
                throw new Error(`No message type provided.`);
            }
            if (!message.id) {
                throw new Error(`No message id provided.`);
            }
            if (type !== `loadModule` && !this.integration) {
                throw new Error(`Integration not loaded but ${type} message was received. The integration worker must be loaded before any other messages are sent.`);
            }
            if (type in this && this[type] && typeof this[type] === `function`) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore there may or may not be args
                const result = await this[type](payload);
                parentPort?.postMessage({
                    id,
                    result,
                });
            }
            else {
                throw new Error(`Unknown message type: ${type}`);
            }
        });
    }
    async loadModule() {
        try {
            const integration = await getIntegrationModule(this.integrationModulePath);
            this.integration = integration;
            this.config = await getConfiguration();
            return true;
        }
        catch (e) {
            console.error(e);
            return false;
        }
    }
    async implementedConnectorAPINames() {
        if (!this.integration) {
            throw new Error(`No integration loaded.`);
        }
        const { apiImplementations } = this.integration.netlifyConnectPlugin || {
            apiImplementations: {},
        };
        const contentEngineApiNames = Object.keys(apiImplementations);
        return contentEngineApiNames;
    }
    async writeConnectorOptionsSchema() {
        if (!this.integration) {
            throw new Error(`No integration loaded.`);
        }
        if (!this.integration.netlifyConnectPlugin) {
            throw new Error(`No connector found in integration.`);
        }
        const optionsSchema = this.integration.netlifyConnectPlugin.getOptionsSchema();
        const optionsSDL = zodToGraphqlSdl(optionsSchema);
        if (!this.config?.slug) {
            throw new Error(`An integration.yaml with a slug is required`);
        }
        const staticDir = path.join(this.integrationDirectory, `site/static/${this.config.slug}/connector`);
        await ensureDir(staticDir);
        const optionsSchemaPath = path.join(staticDir, `options-sdl.gql`);
        await writeFile(optionsSchemaPath, optionsSDL);
        return true;
    }
}
new IntegrationWorker();
