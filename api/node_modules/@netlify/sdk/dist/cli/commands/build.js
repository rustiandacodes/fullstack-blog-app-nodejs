import { execSync } from "child_process";
import { resolve } from "path";
import { existsSync, rmSync } from "fs";
import chalk from "chalk";
import { build as esbuild, context, } from "esbuild";
import { copy } from "esbuild-plugin-copy";
import { IntegrationWorkerManager } from "../worker/manager.js";
import { buildIntegrationUI, generateBuildPlugin, generateConnectPlugin, processHandlers, processWrappers, } from "../index.js";
import { getConfiguration, getExternalDepNames, getIntegrationBuildInfo, getIntegrationModule, } from "../util.js";
export const build = async (opts) => {
    const pwd = process.cwd();
    const isPreview = !!opts.previewUrl;
    const config = await getConfiguration();
    // remove dist folders
    rmSync(resolve(pwd, ".ntli"), { recursive: true, force: true });
    // Lint the project
    if (existsSync(resolve(pwd, "tsconfig.json"))) {
        try {
            execSync(`npx tsc --noEmit --skipLibCheck`, {
                // write errors and output to process stdio
                stdio: `inherit`,
            });
        }
        catch (e) {
            if (e instanceof Error) {
                console.error(chalk.red(e.message));
            }
            return;
        }
    }
    else {
        console.warn(chalk.yellow("No tsconfig.json found. Please add a tsconfig.json to your project."));
    }
    const { outDir, builtPath, sourceFilePath, integrationPackageJson, packageName, } = await getIntegrationBuildInfo({
        directory: pwd,
        outDirOveride: opts.dir,
    });
    const { main } = integrationPackageJson;
    // each function added to this array is invoked when the integration is rebundled
    const rebuildListeners = [];
    function onRebuild(listener) {
        rebuildListeners.push(listener);
    }
    const esbuildOptions = {
        entryPoints: [sourceFilePath],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: builtPath,
        external: getExternalDepNames(integrationPackageJson),
        sourcemap: "linked",
        plugins: [
            copy({
                assets: {
                    // resolved based on cwd
                    from: ["src/assets/**/*"],
                    // ^^ doesn't copy files/dirs starting with . for some reason
                    // adding "src/assets/.**/*" causes the copy plugin to throw errors.
                    // possibly due to changes in the new esbuild watch mode API.
                    // resolved based on outfile
                    to: ["assets"],
                    // watch assets for changes in watch mode
                    watch: opts.watch,
                },
                copyOnStart: true,
            }),
            copy({
                assets: {
                    from: ["./README.md"],
                    to: ["./README.md"],
                    watch: opts.watch,
                },
            }),
        ],
    };
    const integrationWorker = new IntegrationWorkerManager(builtPath);
    if (opts.watch) {
        const buildContext = await context({
            ...esbuildOptions,
            plugins: [
                ...esbuildOptions.plugins,
                {
                    name: "rebuild-listener",
                    setup(build) {
                        let shouldNotifyRebuildListeners = false;
                        // sometimes esbuild immediately rebuilds twice on start,
                        setTimeout(() => 
                        // so only notify listeners if it's been more than 100ms since the build started
                        (shouldNotifyRebuildListeners = true), 1000);
                        let notifying = false;
                        build.onEnd(async () => {
                            if (notifying) {
                                return;
                            }
                            notifying = true;
                            if (shouldNotifyRebuildListeners) {
                                await integrationWorker.reload();
                                for (const listener of rebuildListeners) {
                                    await listener();
                                }
                            }
                            notifying = false;
                        });
                    },
                },
            ],
        });
        await buildContext.rebuild();
        await buildContext.watch();
    }
    else {
        await esbuild(esbuildOptions);
    }
    const integration = await getIntegrationModule(builtPath);
    await integrationWorker.loadModule();
    if (!integration) {
        return false;
    }
    const { all, buildtime, site, connector, watch: watchMode } = opts;
    const buildConnectorPlugin = connector || all;
    const buildAny = all || buildtime || site || buildConnectorPlugin;
    console.log(chalk.white("Netlify Integration detected. Building..."));
    if (all || buildtime) {
        console.log(chalk.white("Generating build hooks..."));
        await generateBuildPlugin(integration, { ...config, slug: isPreview ? "netlify-preview" : config.slug }, {
            path: pwd,
            outDir,
        });
    }
    if (all || site) {
        console.log(chalk.white("Generating Netlify Function handlers..."));
        await processHandlers({
            path: pwd,
            outDir,
        }, { ...config, slug: isPreview ? "netlify-preview" : config.slug });
        await buildIntegrationUI({
            mainPath: main,
            outDir,
            surfaceScriptUrl: opts.previewUrl
                ? `${opts.previewUrl}/ui/integration-ui.js`
                : `https://netlify-integration-${config.slug}.netlify.app/ui/integration-ui.js`,
            watch: watchMode,
            id: config.slug,
        });
    }
    if (all && integration.wrappers) {
        await processWrappers(integration.wrappers, {
            path: pwd,
            outDir,
        });
    }
    if (all || buildConnectorPlugin) {
        console.log(chalk.white("Generating Netlify Connect plugin..."));
        await generateConnectPlugin(integrationWorker, config, {
            path: pwd,
            outDir,
            watchMode,
        });
    }
    console.log(`${chalk.green("Build complete!")}`);
    if (buildAny && watchMode) {
        console.log(chalk.white("Watching for changes..."));
    }
    if (buildConnectorPlugin && watchMode) {
        onRebuild(async () => {
            generateConnectPlugin(integrationWorker, config, {
                path: pwd,
                outDir,
                watchMode,
            });
        });
        onRebuild(() => {
            processHandlers({
                path: pwd,
                outDir,
            }, { ...config, slug: isPreview ? "netlify-preview" : config.slug });
        });
        integration.wrappers &&
            onRebuild(() => {
                processWrappers(integration.wrappers, {
                    path: pwd,
                    outDir,
                });
            });
    }
    if (!opts.watch) {
        integrationWorker.stop();
    }
    return {
        packageName,
        integration,
        onRebuild,
        pwd,
        slug: config.slug,
    };
};
