import readline from "readline";
import chalk from "chalk";
import { getSettings, updateSettings } from "../util.js";
import { build } from "./build.js";
import { preview } from "./preview.js";
export const dev = async (opts) => {
    process.env.NODE_ENV = `development`;
    if (!opts.all && !opts.buildtime && !opts.site && !opts.connector) {
        // default to building everything when there are no flags set
        opts.all = true;
    }
    const buildApi = await build({
        ...opts,
        watch: true,
    });
    if (!buildApi || !buildApi.integration.netlifyConnectPlugin) {
        if (opts.connector) {
            throw new Error(`No Connector found`);
        }
        return;
    }
    const { engine } = await preview({
        ...opts,
        dev: true,
        connector: opts.connector || opts.all,
        // force disabled for now as the UI code doesn't support dev mode yet
        ui: false,
    });
    if ((opts.connector || opts.all) && engine) {
        handleConnectorPlugin({ buildApi, engine });
    }
};
let connectorDevMode = getSettings()?.connectorDevMode || `clear cache on save`;
const handleConnectorPlugin = async ({ buildApi, engine, }) => {
    buildApi.onRebuild(() => {
        // restart content engine with the new bundle.
        // the engine runs in a worker thread and
        // calling .restart() will kill the worker and
        // start a new one that uses the new bundle that was just built.
        console.log(chalk.green("Restarting Content Engine..."));
        engine
            .restart({
            runServer: true,
            clearCache: connectorDevMode === `clear cache on save`,
        })
            .then(() => {
            handleConnectorKeypressListener({ engine });
        });
    });
};
let connectorKeypressListenerAdded = false;
export const handleConnectorKeypressListener = ({ engine, }) => {
    if (!connectorKeypressListenerAdded) {
        connectorKeypressListenerAdded = true;
        readline.emitKeypressEvents(process.stdin);
        process.stdin.setRawMode(true);
        process.stdin.on("keypress", (_str, key) => {
            if (key.name === "m") {
                if (connectorDevMode === `clear cache on save`) {
                    connectorDevMode = `data update on save`;
                }
                else {
                    connectorDevMode = `clear cache on save`;
                }
                updateSettings({ connectorDevMode });
                logMode();
            }
            else if (key.ctrl && key.name === "c") {
                process.exit(); // If user presses CTRL+C, exit the process
            }
            else if (key.name === "r") {
                engine
                    .restart({
                    runServer: true,
                    clearCache: connectorDevMode === `clear cache on save`,
                })
                    .then(() => {
                    logMode();
                });
            }
            else if (key.name === "s") {
                engine.sync().then(logMode);
            }
        });
    }
    logMode();
};
const logMode = () => {
    console.log(chalk.blue(`Keys:`));
    console.log(`${chalk.grey(`[m]`)} mode (${connectorDevMode === `clear cache on save`
        ? chalk.yellow(connectorDevMode)
        : chalk.green(connectorDevMode)})`);
    console.log(`${chalk.grey(`[r]`)} restart process`);
    console.log(`${chalk.grey(`[s]`)} sync data\n`);
};
