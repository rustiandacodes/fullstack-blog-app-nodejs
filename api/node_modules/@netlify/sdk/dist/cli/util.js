import { resolve } from "path";
import os from "os";
import { load } from "js-yaml";
import chalk from "chalk";
import fsExtraPkg from "fs-extra";
import { z } from "zod";
const { readFileSync, existsSync, readJSON } = fsExtraPkg;
const IntegrationConfigurationSchema = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
    slug: z.string().regex(/^[a-z0-9-]+$/, "slug must be lowercase with dashes"),
    scopes: z
        .object({
        all: z.boolean().optional(),
        site: z.array(z.enum(["read", "write"])).optional(),
        env: z.array(z.enum(["read", "write", "delete"])).optional(),
        user: z.array(z.enum(["read", "write"])).optional(),
    })
        .optional(),
    integrationLevel: z.enum(["site", "team", "team-and-site"]).optional(),
});
export const getConfiguration = async () => {
    const pwd = process.cwd();
    const fileName = existsSync(resolve(pwd, "integration.yaml"))
        ? "integration.yaml"
        : "integration.yml";
    try {
        const { config } = load(readFileSync(resolve(pwd, fileName), "utf-8"));
        if (!config) {
            throw new Error("No configuration found");
        }
        const parseResult = IntegrationConfigurationSchema.safeParse(config);
        if (!parseResult.success) {
            console.error(parseResult.error.message);
            throw new Error("Invalid Configuration");
        }
        return config;
    }
    catch (e) {
        console.error(e);
        console.error(`No configuration found in ${fileName} in ${pwd}`);
        process.exit(1);
    }
};
export const getIntegrationModule = async (builtPath) => {
    try {
        const integrationModule = await import(builtPath);
        const { integration } = integrationModule;
        if (!integration) {
            const { sourceFilePath } = await getIntegrationBuildInfo({
                directory: process.cwd(),
            });
            throw new Error(`Your integration must be a named export in your main TS file (at ${sourceFilePath}).

For example:

import { NetlifyIntegration } from "@netlify/sdk";
const integration = new NetlifyIntegration();

export { integration } // <-- this is required.`);
        }
        return integration;
    }
    catch (e) {
        console.log(chalk.red("Could not load module"));
        throw e;
    }
};
export const getIntegrationBuildInfo = async ({ directory, outDirOveride, }) => {
    const integrationPackageJson = await readJSON(resolve(directory, "package.json"));
    const { main } = integrationPackageJson;
    if (!main) {
        throw new Error(`${integrationPackageJson.name || `package`} must set a "main" property in package.json`);
    }
    const sourceFilePath = resolve(directory, main);
    const outDir = outDirOveride || resolve(`${directory}/.ntli`);
    const builtPath = `${outDir}/index.js`;
    const packageName = integrationPackageJson.name;
    return {
        integrationPackageJson,
        sourceFilePath,
        builtPath,
        outDir,
        packageName,
    };
};
export function getDepNames(packageJsonContents, opts) {
    const deps = {
        ...(packageJsonContents.dependencies || {}),
        ...(packageJsonContents.devDependencies || {}),
    };
    return Object.keys(Object.fromEntries(Object.entries(deps).filter(([_, v]) => {
        const shouldExternalize = 
        // dont exclude file:/link: deps because they're local and must be bundled.
        // they wont be installable from NPM when this package is published.
        !v.startsWith("file:") && !v.startsWith("link:");
        return opts.external ? shouldExternalize : !shouldExternalize;
    })));
}
export function getInternalDepNames(packageJsonContents) {
    return getDepNames(packageJsonContents, {
        external: false,
    });
}
export function getExternalDepNames(packageJsonContents) {
    return getDepNames(packageJsonContents, {
        external: true,
    });
}
export function removeBundledDepsFromPackageJsonContents(packageJsonContents) {
    const internalDeps = getInternalDepNames(packageJsonContents);
    function removeInternalDeps(deps) {
        return Object.fromEntries(Object.entries(deps || {}).filter(([depName]) => !internalDeps.includes(depName)));
    }
    return {
        ...packageJsonContents,
        dependencies: removeInternalDeps(packageJsonContents.dependencies),
        devDependencies: removeInternalDeps(packageJsonContents.devDependencies),
    };
}
export const getSettings = () => {
    const settingsPath = os.homedir() + "/.netlify/ntli.json";
    if (!fsExtraPkg.existsSync(settingsPath)) {
        return {};
    }
    const settings = fsExtraPkg.readJSONSync(settingsPath);
    return settings;
};
export const updateSettings = (newSettings) => {
    const settingsPath = os.homedir() + "/.netlify/ntli.json";
    const settings = {
        ...(getSettings() || {}),
        ...newSettings,
    };
    fsExtraPkg.ensureFileSync(settingsPath);
    fsExtraPkg.writeJSONSync(settingsPath, settings);
};
